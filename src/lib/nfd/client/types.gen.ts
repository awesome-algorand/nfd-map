// This file is auto-generated by @hey-api/openapi-ts

/**
 * BlueskyRecord contains information about an NFD w/ Verified Blueesky account and basic info on its metrics
 */
export type BlueskyRecord = {
  blueskydid: string;
  displayName: string;
  followers: number;
  following: number;
  handle: string;
  nfd: Nfd;
  posts: number;
};

/**
 * ConsensusRecord contains information about an account that participated in consensus
 */
export type ConsensusRecord = {
  account: string;
  lastPropBlock?: number;
  lastPropTime?: string;
  lastVoteBlock?: number;
  lastVoteTime?: string;
  linkType?: string;
  ownerAccount: string;
  pctOfOnline: number;
  proposals?: number;
  rank?: number;
  votes?: number;
};

export type ContractLockRequestBody = {
  /**
   * Whether to lock (true), or unlock (false)
   */
  lock: boolean;
  /**
   * Sender of transaction - needs to be owner of NFD
   */
  sender: string;
};

/**
 * Donation contains basic information about donation totals to specific addresses from accounts related to an NFD
 */
export type Donation = {
  /**
   * Sender or Receiver Algorand address depending on request
   */
  address: string;
  /**
   * Total donation in microAlgos
   */
  total: number;
};

export type _Error = {
  /**
   * Is the error a server-side fault?
   */
  fault: boolean;
  /**
   * ID is a unique identifier for this particular occurrence of the problem.
   */
  id: string;
  /**
   * Message is a human-readable explanation specific to this occurrence of the problem.
   */
  message: string;
  /**
   * Name is the name of this class of errors.
   */
  name: string;
  /**
   * Is the error temporary?
   */
  temporary: boolean;
  /**
   * Is the error a timeout?
   */
  timeout: boolean;
};

export type GetQuoteResponseBody = {
  /**
   * extra needed to cover MBR (if necessary) - price already includes this amount
   */
  carryCost: number;
  /**
   * whether the nfd exists. if so, cost is renewal, otherwise mint (including carry)
   */
  exists: boolean;
  /**
   * if nfd is in auction pricing for given buyer
   */
  inAuction: boolean;
  /**
   * whether the (existing) nfd is expired
   */
  isExpired: boolean;
  /**
   * price in microAlgo for 1 year w/ carry cost (if needs minted) added in. subtract carry cost for per-year cost
   */
  price: number;
};

/**
 * Whether NFD NFT ASA ID is for authentic NFD
 */
export type IsValidAsaResponseBody = {
  appID: number;
  isValid: boolean;
  message: string;
  name: string;
};

/**
 * Whether NFD App ID is for authentic NFD
 */
export type IsValidNfdResponseBody = {
  isValid: boolean;
  message: string;
  name: string;
  sigNameAddress?: string;
};

export type LinkAddressRequestBody = {
  /**
   * Address(es) to link to the NFD (must be able to sign for each)
   */
  address: Array<string>;
  /**
   * Address that will be signing the returned transactions.  Should be owner of NFD
   */
  sender: string;
};

export type MintRequestBody = {
  /**
   * Offer price in ALGO. Expiration time set prorated based on amount paid vs fixed per-year cost when years argument is used
   */
  algoOffer?: number;
  /**
   * Address paying/signing for minting transaction
   */
  buyer: string;
  name: string;
  /**
   * Address NFD is being minted for if not buyer
   */
  reservedFor?: string;
  /**
   * Number of years until expiration, 1 yr minimum, 20 max, extending renewal date - sets price in multiples of 1 year
   */
  years?: number;
};

/**
 * NFD contains all known information about an NFD record
 */
export type Nfd = {
  /**
   * NFD Application ID
   */
  appID?: number;
  /**
   * NFD ASA ID
   */
  asaID?: number;
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   */
  avatarOutdated?: boolean;
  /**
   * Verified Algorand addresses for this NFD
   */
  caAlgo?: Array<string>;
  /**
   * Cache-Control header
   */
  "cache-control"?: string;
  category?: "curated" | "premium" | "common";
  /**
   * Round this data was last fetched from
   */
  currentAsOfBlock?: number;
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   */
  depositAccount?: string;
  /**
   * ETag
   */
  etag?: string;
  expired?: boolean;
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  /**
   * Tags set by the system for tracking/analytics
   */
  metaTags?: Array<string>;
  name: string;
  nfdAccount?: string;
  /**
   * Owner of NFD
   */
  owner?: string;
  /**
   * NFD Application ID of Parent if this is a segment
   */
  parentAppID?: number;
  properties?: NfdProperties;
  /**
   * Reserved owner of NFD
   */
  reservedFor?: string;
  saleType?: "auction" | "buyItNow";
  /**
   * amount NFD is being sold for (microAlgos)
   */
  sellAmount?: number;
  /**
   * RecipientUid of NFD sales
   */
  seller?: string;
  sigNameAddress?: string;
  state?:
    | "available"
    | "minting"
    | "reserved"
    | "forSale"
    | "owned"
    | "expired";
  /**
   * Tags assigned to this NFD
   */
  tags?: Array<string>;
  timeChanged?: string;
  timeCreated?: string;
  timeExpires?: string;
  timePurchased?: string;
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   */
  unverifiedCa?: {
    [key: string]: Array<string>;
  };
  /**
   * Unverified Algorand addresses for this NFD
   */
  unverifiedCaAlgo?: Array<string>;
};

/**
 * NFDActivity contains the property changes made in a particular NFD contract update call
 */
export type NfdActivity = {
  /**
   * Algorand Block number of change
   */
  block: number;
  /**
   * Cache-Control header
   */
  "cache-control"?: string;
  /**
   * Changed properties
   */
  changes?: {
    [key: string]: string;
  };
  /**
   * ETag
   */
  etag?: string;
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  /**
   * NFD Name
   */
  name: string;
  timeChanged: string;
};

/**
 * NFDAnalyticEvent contains a price history record for a point in time of an NFD
 */
export type NfdAnalyticEvent = {
  block?: number;
  buyer?: string;
  /**
   * extra amount paid to cover minimum balance requirements - add to price to determine total amount paid
   */
  carryCost?: number;
  category?: "curated" | "premium" | "common";
  /**
   * NFD current owner - if set via includeOwner property
   */
  currentOwner?: string;
  event?:
    | "minted"
    | "renewed"
    | "offeredForSale"
    | "canceledSale"
    | "escrowedOffer"
    | "sold"
    | "postedOffer";
  groupID?: string;
  metaTags?: Array<string>;
  /**
   * NFD Name
   */
  name?: string;
  /**
   * new expiration time set from minting or renewing
   */
  newExpTime?: string;
  note?: string;
  /**
   * price for one year mint/renew
   */
  oneYearRenewalPrice?: number;
  saleType?: "auction" | "buyItNow";
  seller?: string;
};

/**
 * NFDAnalyticRecord is an NFD Analytics record in a time-series collection, with timestamp, price, and event data for that point in time.
 */
export type NfdAnalyticRecord = {
  data?: NfdAnalyticEvent;
  /**
   * price of event in microAlgos
   */
  price?: number;
  /**
   * price of event in USD
   */
  priceUsd?: number;
  timestamp?: string;
};

export type NfdAnalyticRecords = {
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  results: Array<NfdAnalyticRecord>;
  /**
   * total number of results, with data containing paged amount based on offset/limit
   */
  total: number;
};

/**
 * NFDProperties contains the expanded metadata stored within an NFD contracts' global-state
 */
export type NfdProperties = {
  /**
   * Internal properties
   */
  internal?: {
    [key: string]: string;
  };
  /**
   * User properties
   */
  userDefined?: {
    [key: string]: string;
  };
  /**
   * Verified properties
   */
  verified?: {
    [key: string]: string;
  };
};

export type NfdRecord = {
  /**
   * NFD Application ID
   */
  appID?: number;
  /**
   * NFD ASA ID
   */
  asaID?: number;
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   */
  avatarOutdated?: boolean;
  /**
   * Verified Algorand addresses for this NFD
   */
  caAlgo?: Array<string>;
  category?: "curated" | "premium" | "common";
  /**
   * Round this data was last fetched from
   */
  currentAsOfBlock?: number;
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   */
  depositAccount?: string;
  expired?: boolean;
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  /**
   * Tags set by the system for tracking/analytics
   */
  metaTags?: Array<string>;
  name: string;
  nfdAccount?: string;
  /**
   * Owner of NFD
   */
  owner?: string;
  /**
   * NFD Application ID of Parent if this is a segment
   */
  parentAppID?: number;
  properties?: NfdProperties;
  /**
   * Reserved owner of NFD
   */
  reservedFor?: string;
  saleType?: "auction" | "buyItNow";
  /**
   * amount NFD is being sold for (microAlgos)
   */
  sellAmount?: number;
  /**
   * RecipientUid of NFD sales
   */
  seller?: string;
  sigNameAddress?: string;
  state?:
    | "available"
    | "minting"
    | "reserved"
    | "forSale"
    | "owned"
    | "expired";
  /**
   * Tags assigned to this NFD
   */
  tags?: Array<string>;
  timeChanged?: string;
  timeCreated?: string;
  timeExpires?: string;
  timePurchased?: string;
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   */
  unverifiedCa?: {
    [key: string]: Array<string>;
  };
  /**
   * Unverified Algorand addresses for this NFD
   */
  unverifiedCaAlgo?: Array<string>;
};

export type NfdRecordCollection = Array<NfdRecord>;

/**
 * NFD contains all known information about an NFD record (full view)
 */
export type NfdRecordResponseFull = {
  /**
   * NFD Application ID
   */
  appID?: number;
  /**
   * NFD ASA ID
   */
  asaID?: number;
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   */
  avatarOutdated?: boolean;
  /**
   * Verified Algorand addresses for this NFD
   */
  caAlgo?: Array<string>;
  /**
   * Cache-Control header
   */
  "cache-control"?: string;
  category?: "curated" | "premium" | "common";
  /**
   * Round this data was last fetched from
   */
  currentAsOfBlock?: number;
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   */
  depositAccount?: string;
  /**
   * ETag
   */
  etag?: string;
  expired?: boolean;
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  /**
   * Tags set by the system for tracking/analytics
   */
  metaTags?: Array<string>;
  name: string;
  nfdAccount?: string;
  /**
   * Owner of NFD
   */
  owner?: string;
  /**
   * NFD Application ID of Parent if this is a segment
   */
  parentAppID?: number;
  properties?: NfdProperties;
  /**
   * Reserved owner of NFD
   */
  reservedFor?: string;
  saleType?: "auction" | "buyItNow";
  /**
   * amount NFD is being sold for (microAlgos)
   */
  sellAmount?: number;
  /**
   * RecipientUid of NFD sales
   */
  seller?: string;
  sigNameAddress?: string;
  state?:
    | "available"
    | "minting"
    | "reserved"
    | "forSale"
    | "owned"
    | "expired";
  /**
   * Tags assigned to this NFD
   */
  tags?: Array<string>;
  timeChanged?: string;
  timeCreated?: string;
  timeExpires?: string;
  timePurchased?: string;
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   */
  unverifiedCa?: {
    [key: string]: Array<string>;
  };
  /**
   * Unverified Algorand addresses for this NFD
   */
  unverifiedCaAlgo?: Array<string>;
};

/**
 * DonationListV2ResponseBody is the result type for an array of NfdRecordResponse (full view)
 */
export type NfdRecordResponseFullCollection = Array<NfdRecordResponseFull>;

/**
 * NFD contains all known information about an NFD record
 */
export type NfdRecordinaddress = {
  /**
   * NFD Application ID
   */
  appID?: number;
  /**
   * NFD ASA ID
   */
  asaID?: number;
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   */
  avatarOutdated?: boolean;
  /**
   * Verified Algorand addresses for this NFD
   */
  caAlgo?: Array<string>;
  /**
   * Cache-Control header
   */
  "cache-control"?: string;
  category?: "curated" | "premium" | "common";
  /**
   * Round this data was last fetched from
   */
  currentAsOfBlock?: number;
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   */
  depositAccount?: string;
  /**
   * ETag
   */
  etag?: string;
  expired?: boolean;
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  /**
   * Tags set by the system for tracking/analytics
   */
  metaTags?: Array<string>;
  name: string;
  nfdAccount?: string;
  /**
   * Owner of NFD
   */
  owner?: string;
  /**
   * NFD Application ID of Parent if this is a segment
   */
  parentAppID?: number;
  properties?: NfdProperties;
  /**
   * Reserved owner of NFD
   */
  reservedFor?: string;
  saleType?: "auction" | "buyItNow";
  /**
   * amount NFD is being sold for (microAlgos)
   */
  sellAmount?: number;
  /**
   * RecipientUid of NFD sales
   */
  seller?: string;
  sigNameAddress?: string;
  state?:
    | "available"
    | "minting"
    | "reserved"
    | "forSale"
    | "owned"
    | "expired";
  /**
   * Tags assigned to this NFD
   */
  tags?: Array<string>;
  timeChanged?: string;
  timeCreated?: string;
  timeExpires?: string;
  timePurchased?: string;
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   */
  unverifiedCa?: {
    [key: string]: Array<string>;
  };
  /**
   * Unverified Algorand addresses for this NFD
   */
  unverifiedCaAlgo?: Array<string>;
};

export type NfdRecordinaddressCollection = Array<NfdRecordinaddress>;

export type NfdV2SearchRecords = {
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  nfds: NfdRecordCollection;
  /**
   * total number of results, with data containing paged amount based on offset/limit
   */
  total: number;
};

export type OfferRequestBody = {
  /**
   * Amount in microAlgo to sell the NFD for.  1 ALGO is 1,000,000 microAlgo. 100 million maximum.
   */
  offer: number;
  /**
   * Whether to pay the offer amount + fees to the account the NFD is reserved for.  Equivalent to 'gifting' the NFD
   */
  payReceiver?: boolean;
  reservedFor?: string;
  /**
   * Sender of transaction - needs to be owner of NFD
   */
  sender: string;
};

export type PostOfferToOwnerRequestBody = {
  /**
   * Note to pass along to the NFD owner.  Must be provided but can be blank
   */
  note: string;
  /**
   * Amount in microAlgo being offered to the NFD owner
   */
  offer: number;
  sender: string;
};

export type PurchaseRequestBody = {
  buyer: string;
  /**
   * Amount in microAlgo to purchase/claim the NFD for
   */
  offer: number;
};

export type RateLimited = {
  limit: number;
  secsRemaining: number;
};

export type RenewRequestBody = {
  /**
   * Offer price in ALGO. Expiration time set prorated based on amount paid vs fixed per-year cost when years argument is used
   */
  algoOffer?: number;
  /**
   * Address paying/signing for minting transaction
   */
  buyer: string;
  name: string;
  /**
   * Number of years until expiration, 1 yr minimum, 20 max, extending renewal date - sets price in multiples of 1 year. If not current owner and expired, only 1 year is allowed
   */
  years?: number;
};

export type RescindOfferRequestBody = {
  /**
   * Sender of transaction - needs to be owner of NFD
   */
  sender: string;
};

export type SegmentLockRequestBody = {
  /**
   * Whether to lock (true), or unlock (false)
   */
  lock: boolean;
  /**
   * amount users minting off the segment have to pay to mint in USD (in cents - ie: 300 = $3.00). Set to 0 if locking
   */
  sellAmount: number;
  /**
   * Sender of transaction - needs to be owner of NFD
   */
  sender: string;
};

export type SendFromVaultRequestBody = {
  /**
   * Base amount (in base units of specified asset - so decimals must be considered) of asset to send.   If multiple assets are specified, amount is should be 0 as ALL of each are sent and closed out
   */
  amount?: number;
  /**
   * String version of Base amount (in base units of specified asset - so decimals must be considered) of asset to send.  This is used to work around JS deficiencies with bigint
   */
  amountStr?: string;
  /**
   * Algorand ASA IDs to transfer FROM vault - use asset 0 to send ALGO.  Specifying multiple assets means ALL of each are sent and amount is ignored. If receiver is a vault and needs to opt-in, then need MBR/opt-in pairs (5 pairs - 8  opt-ins each - 40 assets), then 6 send calls of 7 assets w/ 5 at end for total of 40.  If receiver is already opted-in, then 112 (7 per txn, 16 tnxs) is max.
   */
  assets: Array<number>;
  /**
   * Optional note to include in asset send transaction
   */
  note?: string;
  /**
   * Algorand account or NFD Name (if vault receiver) the asset(s) should be sent to
   */
  receiver: string;
  /**
   * Specifies that the receiver account is something the caller can sign for. If specified, then opt-in transactions it signs may be included
   */
  receiverCanSign?: boolean;
  /**
   * Type of receiver, 'account', or 'nfdVault'
   */
  receiverType?: "account" | "nfdVault";
  /**
   * Sender of transaction, must be NFD owner
   */
  sender: string;
};

export type SendToVaultRequestBody = {
  /**
   * Base amount (in base units of specified asset - so decimals must be considered) of asset to send.   If multiple assets specified, amount is ignored and ALL of each are sent
   */
  amount?: number;
  /**
   * String version of Base amount (in base units of specified asset - so decimals must be considered) of asset to send.  This is used to work around JS deficiencies with bigint
   */
  amountStr?: string;
  /**
   * Algorand ASA IDs to transfer (and opt-in inside vault if necessary) - use asset 0 to send ALGO.  Specifying multiple assets means ALL of each are sent and amount is ignored. 13 is max assets that can be specified if they're being sent (2 for MBR payments, 2 for opt-in txns (8+4 asset opt-ins), 12 asset transfers).  If opt-in only then 64 is maximum (1 MBR per 8 assets, 8 assets per txn * 8 txns)
   */
  assets: Array<number>;
  /**
   * Optional note to include in asset send transaction
   */
  note?: string;
  /**
   * Whether to only opt-in to the asset, instead of including asset transfer txn
   */
  optInOnly: boolean;
  sender: string;
};

export type SetPrimaryAddressRequestBody = {
  /**
   * The address (already linked) to make primary - swapping into position if necessary
   */
  address: string;
  /**
   * Address that will be signing the returned transactions.  Should be owner of NFD
   */
  sender: string;
};

export type TotalsOkResponseBody = {
  contractTotals: {
    /**
     * Contract versions
     */
    allVersions?: {
      [key: string]: number;
    };
    /**
     * Contract versions
     */
    majorVersions?: {
      [key: string]: number;
    };
  };
  /**
   * NFDs that have expired
   */
  expiredTotal: number;
  forSale: number;
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   */
  "match-check"?: string;
  mintedTotals: {
    day?: number;
    lifetime?: number;
    month?: number;
    week?: number;
  };
  segmentTotals: {
    day?: number;
    lifetime?: number;
    month?: number;
    week?: number;
  };
  soldTotals: {
    day?: number;
    lifetime?: number;
    month?: number;
    week?: number;
  };
  total: number;
  totalSegments: number;
  uniqueOwners: number;
};

/**
 * TwitterRecord contains information about an NFD w/ Verified Twitter account and basic info on its twitter metrics
 */
export type TwitterRecord = {
  followers: number;
  following: number;
  nfd: Nfd;
  timeChanged: string;
  tweets: number;
  twitterHandle: string;
};

export type UpdatePartialRequestBody = {
  properties: NfdProperties;
  /**
   * Address that will be signing the returned transactions.  Should be owner of NFD
   */
  sender: string;
};

export type VerifyConfirmRequestBody = {
  /**
   * Challenge value, optional depending on verification type
   */
  challenge?: string;
};

/**
 * Whether verification was successful
 */
export type VerifyConfirmResponseBody = {
  confirmed: boolean;
};

export type VerifyRequestRequestBody = {
  /**
   * User defined field name to verify
   */
  fieldToVerify:
    | "blueskydid"
    | "twitter"
    | "github"
    | "domain"
    | "email"
    | "avatar"
    | "banner";
  name: string;
  /**
   * Sender of transaction - needs to be owner of NFD
   */
  sender: string;
};

/**
 * Data to use as part of verification
 */
export type VerifyRequestResponseBody = {
  /**
   * Challenge to be used as part of verification process, with use specific to each field
   */
  challenge: string;
  /**
   * ID of challenge, must be used in subsequent confirmation call but may be blank
   */
  id: string;
  /**
   * If set, no confirmation is required, the verify call was sufficient
   */
  validated?: boolean;
};

export type VersionResponseBody = {
  appVersion: string;
  contractVersion: string;
};

export type InfoInfoOpenapi3YamlData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/info/openapi3.yaml";
};

export type InfoInfoOpenapi3YamlResponses = {
  /**
   * File downloaded
   */
  200: unknown;
};

export type InfoVersionData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/info/version";
};

export type InfoVersionResponses = {
  /**
   * OK response.
   */
  200: VersionResponseBody;
};

export type InfoVersionResponse =
  InfoVersionResponses[keyof InfoVersionResponses];

export type NfdGetNfdData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path: {
    /**
     * Name of a NFD (alphanumeric only or emojis/alphanumeric), or an NFD Application ID
     */
    nameOrID: string;
  };
  query?: {
    /**
     * View of data to return, tiny, brief (default), or full
     */
    view?: "tiny" | "brief" | "full";
    /**
     * Use if polling waiting for state change - causes notFound to return as 204 instead of 404.  Should only be used when waiting for an NFD to transition from not-existing to being reserved for user to claim
     */
    poll?: boolean;
    /**
     * Set to true to return a never-cached result.  Use sparingly and only during certain 'NFD already exists' UX state transitions.
     */
    nocache?: boolean;
  };
  url: "/nfd/{nameOrID}";
};

export type NfdGetNfdErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdGetNfdError = NfdGetNfdErrors[keyof NfdGetNfdErrors];

export type NfdGetNfdResponses = {
  /**
   * OK response.
   */
  200: NfdRecord;
  /**
   * Polling, NFD not found
   */
  204: void;
};

export type NfdGetNfdResponse = NfdGetNfdResponses[keyof NfdGetNfdResponses];

export type NfdActivityData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query: {
    /**
     * Name(s) of NFDs to fetch activity for.  Specify the same query parameter multiple times for each nane, ie: name=xxx&name=yyy&name=zzz")
     */
    name: Array<string>;
    /**
     * type of activity to retrieve
     */
    type?: "changes";
    /**
     * Fetch events that occurred only after the specified time
     */
    afterTime?: string;
    /**
     * Limit the number of results returned, per NFD - max 50
     */
    limit?: number;
    /**
     * What to sort on - descending timestamp is default
     */
    sort?: "timeDesc" | "timeAsc";
  };
  url: "/nfd/activity";
};

export type NfdActivityErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdActivityError = NfdActivityErrors[keyof NfdActivityErrors];

export type NfdActivityResponses = {
  /**
   * OK response.
   */
  200: Array<NfdActivity>;
};

export type NfdActivityResponse =
  NfdActivityResponses[keyof NfdActivityResponses];

export type NfdAnalyticsData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: {
    /**
     * name or partial match of NFD name to filter on
     */
    name?: string;
    /**
     * An Algorand Account address
     */
    buyer?: string;
    /**
     * An Algorand Account address
     */
    seller?: string;
    /**
     * one or more events to filter on
     */
    event?: Array<
      | "minted"
      | "renewed"
      | "offeredForSale"
      | "canceledSale"
      | "escrowedOffer"
      | "sold"
      | "postedOffer"
    >;
    /**
     * Whether the buyer property must be present in the data.  Setting this will exclude auction mint events for eg
     */
    requireBuyer?: boolean;
    /**
     * Whether to add a currentOwner property to each event with the 'current' owner of the NFD referenced by that event
     */
    includeOwner?: boolean;
    /**
     * Whether to exclude events where NFDomains is the seller.  If set to true, and filtering on 'sold' event for eg, returned items will will be secondary sales only.
     */
    excludeNFDAsSeller?: boolean;
    category?: Array<"curated" | "premium" | "common">;
    saleType?: Array<"auction" | "buyItNow">;
    /**
     * Length of NFD
     */
    length?: Array<
      | "1_letters"
      | "2_letters"
      | "3_letters"
      | "4_letters"
      | "5_letters"
      | "6_letters"
      | "7_letters"
      | "8_letters"
      | "9_letters"
      | "10+_letters"
    >;
    /**
     * Traits of NFD
     */
    traits?: Array<"emoji" | "pristine" | "segment">;
    /**
     * The parent NFD Application ID to find. Used for fetching segments of an NFD
     */
    parentAppID?: number;
    /**
     * Minimum price of NFD
     */
    minPrice?: number;
    /**
     * Maximum price of NFD
     */
    maxPrice?: number;
    /**
     * Fetch analytics events that occurred only after the specified time
     */
    afterTime?: string;
    /**
     * Limit the number of results returned - max 200
     */
    limit?: number;
    /**
     * Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     */
    offset?: number;
    /**
     * What to sort on - descending timestamp is default
     */
    sort?: "timeDesc" | "priceAsc" | "priceDesc";
  };
  url: "/nfd/analytics";
};

export type NfdAnalyticsErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdAnalyticsError = NfdAnalyticsErrors[keyof NfdAnalyticsErrors];

export type NfdAnalyticsResponses = {
  /**
   * OK response.
   */
  200: NfdAnalyticRecords;
};

export type NfdAnalyticsResponse =
  NfdAnalyticsResponses[keyof NfdAnalyticsResponses];

export type NfdBadgesData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/badges/{name}";
};

export type NfdBadgesErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdBadgesError = NfdBadgesErrors[keyof NfdBadgesErrors];

export type NfdBadgesResponses = {
  /**
   * OK response.
   */
  200: {
    [key: string]: Array<{
      [key: string]: string;
    }>;
  };
};

export type NfdBadgesResponse = NfdBadgesResponses[keyof NfdBadgesResponses];

export type NfdBlueskyLeadersData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: never;
  url: "/nfd/bluesky/leaders";
};

export type NfdBlueskyLeadersErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdBlueskyLeadersError =
  NfdBlueskyLeadersErrors[keyof NfdBlueskyLeadersErrors];

export type NfdBlueskyLeadersResponses = {
  /**
   * OK response.
   */
  200: Array<BlueskyRecord>;
};

export type NfdBlueskyLeadersResponse =
  NfdBlueskyLeadersResponses[keyof NfdBlueskyLeadersResponses];

export type NfdBrowseData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: {
    /**
     * name or partial match of NFD name to filter on
     */
    name?: string;
    category?: Array<"curated" | "premium" | "common">;
    saleType?: Array<"auction" | "buyItNow">;
    state?: Array<"reserved" | "forSale" | "owned" | "expired">;
    /**
     * The parent NFD Application ID to find. Used for fetching segments of an NFD
     */
    parentAppID?: number;
    /**
     * Length of NFD
     */
    length?: Array<
      | "1_letters"
      | "2_letters"
      | "3_letters"
      | "4_letters"
      | "5_letters"
      | "6_letters"
      | "7_letters"
      | "8_letters"
      | "9_letters"
      | "10+_letters"
    >;
    /**
     * Traits of NFD
     */
    traits?: Array<"emoji" | "pristine" | "segment">;
    /**
     * An Algorand Account address
     */
    owner?: string;
    /**
     * An Algorand Account address
     */
    reservedFor?: string;
    /**
     * The start of an NFD name, fetching multiple NFDs that have that prefix
     */
    prefix?: string;
    /**
     * Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     */
    substring?: string;
    /**
     * Verified property name to search on - specify value with vvalue
     */
    vproperty?:
      | "blueskydid"
      | "discord"
      | "telegram"
      | "github"
      | "twitter"
      | "email"
      | "domain"
      | "nostrpubkey";
    /**
     * Value to find in the vproperty field specified with the vproperty parameter
     */
    vvalue?: string;
    /**
     * Minimum price of NFD
     */
    minPrice?: number;
    /**
     * Maximum price of NFD
     */
    maxPrice?: number;
    /**
     * Fetch NFDs that changed after the specified timestamp
     */
    changedAfter?: string;
    /**
     * Limit the number of results returned - max 200
     */
    limit?: number;
    /**
     * Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     */
    offset?: number;
    /**
     * What to sort on
     */
    sort?:
      | "createdDesc"
      | "timeChangedDesc"
      | "soldDesc"
      | "priceAsc"
      | "priceDesc"
      | "highestSaleDesc"
      | "saleTypeAsc";
    /**
     * View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     */
    view?: "tiny" | "brief" | "full";
  };
  url: "/nfd/browse";
};

export type NfdBrowseErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdBrowseError = NfdBrowseErrors[keyof NfdBrowseErrors];

export type NfdBrowseResponses = {
  /**
   * OK response.
   */
  200: NfdRecordCollection;
};

export type NfdBrowseResponse = NfdBrowseResponses[keyof NfdBrowseResponses];

export type NfdConsensusLeadersData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: {
    /**
     * should it only match against accounts matching NFD linked addresses
     */
    requireNFD?: boolean;
  };
  url: "/nfd/consensus/leaders";
};

export type NfdConsensusLeadersErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdConsensusLeadersError =
  NfdConsensusLeadersErrors[keyof NfdConsensusLeadersErrors];

export type NfdConsensusLeadersResponses = {
  /**
   * OK response.
   */
  200: Array<ConsensusRecord>;
};

export type NfdConsensusLeadersResponse =
  NfdConsensusLeadersResponses[keyof NfdConsensusLeadersResponses];

export type NfdConsensusMetricsData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: never;
  url: "/nfd/consensus/metrics";
};

export type NfdConsensusMetricsErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdConsensusMetricsError =
  NfdConsensusMetricsErrors[keyof NfdConsensusMetricsErrors];

export type NfdConsensusMetricsResponses = {
  /**
   * OK response.
   */
  200: {
    [key: string]: Array<{
      [key: string]: string;
    }>;
  };
};

export type NfdConsensusMetricsResponse =
  NfdConsensusMetricsResponses[keyof NfdConsensusMetricsResponses];

export type NfdContractLockData = {
  body: ContractLockRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/contract/lock/{name}";
};

export type NfdContractLockErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdContractLockError =
  NfdContractLockErrors[keyof NfdContractLockErrors];

export type NfdContractLockResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdContractLockResponse =
  NfdContractLockResponses[keyof NfdContractLockResponses];

export type NfdContractUpgradeData = {
  body: RescindOfferRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/contract/upgrade/{name}";
};

export type NfdContractUpgradeErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeNotNeeded: The NFD contract doesn't need upgraded
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdContractUpgradeError =
  NfdContractUpgradeErrors[keyof NfdContractUpgradeErrors];

export type NfdContractUpgradeResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdContractUpgradeResponse =
  NfdContractUpgradeResponses[keyof NfdContractUpgradeResponses];

export type NfdDonationsData = {
  body?: never;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/donations/{name}";
};

export type NfdDonationsErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdDonationsError = NfdDonationsErrors[keyof NfdDonationsErrors];

export type NfdDonationsResponses = {
  /**
   * OK response.
   */
  200: Array<Donation>;
};

export type NfdDonationsResponse =
  NfdDonationsResponses[keyof NfdDonationsResponses];

export type NfdGetQuoteData = {
  body?: never;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query: {
    /**
     * An Algorand Account address
     */
    buyer: string;
  };
  url: "/nfd/getQuote/{name}";
};

export type NfdGetQuoteErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: unknown;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdGetQuoteError = NfdGetQuoteErrors[keyof NfdGetQuoteErrors];

export type NfdGetQuoteResponses = {
  /**
   * OK response.
   */
  200: GetQuoteResponseBody;
};

export type NfdGetQuoteResponse =
  NfdGetQuoteResponses[keyof NfdGetQuoteResponses];

export type NfdIsValidNfdData = {
  body?: never;
  path: {
    /**
     * Application ID of a presumed NFD to verify.  The API will perform a forward-name lookup of the name within the NFD to verify it points to the same ID
     */
    appID: number;
  };
  query?: never;
  url: "/nfd/isValid/{appID}";
};

export type NfdIsValidNfdErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdIsValidNfdError = NfdIsValidNfdErrors[keyof NfdIsValidNfdErrors];

export type NfdIsValidNfdResponses = {
  /**
   * OK response.
   */
  200: IsValidNfdResponseBody;
};

export type NfdIsValidNfdResponse =
  NfdIsValidNfdResponses[keyof NfdIsValidNfdResponses];

export type NfdIsValidAsaData = {
  body?: never;
  path: {
    /**
     * Asset ID of a presumed NFD ASA to verify.  The API will verify the found asset references an NFD that in turn references that asset.
     */
    asaID: number;
  };
  query?: never;
  url: "/nfd/isValidASA/{asaID}";
};

export type NfdIsValidAsaErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdIsValidAsaError = NfdIsValidAsaErrors[keyof NfdIsValidAsaErrors];

export type NfdIsValidAsaResponses = {
  /**
   * OK response.
   */
  200: IsValidAsaResponseBody;
};

export type NfdIsValidAsaResponse =
  NfdIsValidAsaResponses[keyof NfdIsValidAsaResponses];

export type NfdLinkAddressData = {
  body: LinkAddressRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/links/addAddress/{name}";
};

export type NfdLinkAddressErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdLinkAddressError =
  NfdLinkAddressErrors[keyof NfdLinkAddressErrors];

export type NfdLinkAddressResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  202: string;
};

export type NfdLinkAddressResponse =
  NfdLinkAddressResponses[keyof NfdLinkAddressResponses];

export type NfdUnlinkAddressData = {
  body: LinkAddressRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/links/removeAddress/{name}";
};

export type NfdUnlinkAddressErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdUnlinkAddressError =
  NfdUnlinkAddressErrors[keyof NfdUnlinkAddressErrors];

export type NfdUnlinkAddressResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  202: string;
};

export type NfdUnlinkAddressResponse =
  NfdUnlinkAddressResponses[keyof NfdUnlinkAddressResponses];

export type NfdSetPrimaryAddressData = {
  body: SetPrimaryAddressRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/links/setPrimaryAddress/{name}";
};

export type NfdSetPrimaryAddressErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSetPrimaryAddressError =
  NfdSetPrimaryAddressErrors[keyof NfdSetPrimaryAddressErrors];

export type NfdSetPrimaryAddressResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  202: string;
};

export type NfdSetPrimaryAddressResponse =
  NfdSetPrimaryAddressResponses[keyof NfdSetPrimaryAddressResponses];

export type NfdSetPrimaryNfdData = {
  body: SetPrimaryAddressRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/links/setPrimaryNFD/{name}";
};

export type NfdSetPrimaryNfdErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSetPrimaryNfdError =
  NfdSetPrimaryNfdErrors[keyof NfdSetPrimaryNfdErrors];

export type NfdSetPrimaryNfdResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  202: string;
};

export type NfdSetPrimaryNfdResponse =
  NfdSetPrimaryNfdResponses[keyof NfdSetPrimaryNfdResponses];

export type NfdGetLookupData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query: {
    /**
     * one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address=xxx&address=yyy&address=zzz
     */
    address: Array<string>;
    /**
     * View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     */
    view?: "tiny" | "thumbnail" | "brief" | "full";
    /**
     * Whether to allow unverified addresses to match (and only if its only match).  Defaults to false
     */
    allowUnverified?: boolean;
  };
  url: "/nfd/lookup";
};

export type NfdGetLookupErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: unknown;
  /**
   * notFound: Not Found response.
   */
  404: unknown;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdGetLookupError = NfdGetLookupErrors[keyof NfdGetLookupErrors];

export type NfdGetLookupResponses = {
  /**
   * OK response.
   */
  200: {
    [key: string]: NfdRecordinaddress;
  };
};

export type NfdGetLookupResponse =
  NfdGetLookupResponses[keyof NfdGetLookupResponses];

export type NfdMintData = {
  body: MintRequestBody;
  path?: never;
  query?: never;
  url: "/nfd/mint";
};

export type NfdMintErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: unknown;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdMintError = NfdMintErrors[keyof NfdMintErrors];

export type NfdMintResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  201: string;
  /**
   * alreadyExists: NFD already exists
   */
  204: void;
};

export type NfdMintResponse = NfdMintResponses[keyof NfdMintResponses];

export type NfdGetNameSigData = {
  body?: never;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/nameSig/{name}";
};

export type NfdGetNameSigErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdGetNameSigError = NfdGetNameSigErrors[keyof NfdGetNameSigErrors];

export type NfdGetNameSigResponses = {
  /**
   * Algorand Address of Smart-Sig NAME account
   */
  200: string;
};

export type NfdGetNameSigResponse =
  NfdGetNameSigResponses[keyof NfdGetNameSigResponses];

export type NfdOfferData = {
  body: OfferRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/offer/{name}";
};

export type NfdOfferErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * tooManyTransactions: The number of transactions allowed in a single transaction group (16) have been exceeded.  Update fewer fields in one transaction, or if selling, reduce the data within the NFD first.
   */
  413: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdOfferError = NfdOfferErrors[keyof NfdOfferErrors];

export type NfdOfferResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdOfferResponse = NfdOfferResponses[keyof NfdOfferResponses];

export type NfdPostOfferToOwnerData = {
  body: PostOfferToOwnerRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/postOfferToOwner/{name}";
};

export type NfdPostOfferToOwnerErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdPostOfferToOwnerError =
  NfdPostOfferToOwnerErrors[keyof NfdPostOfferToOwnerErrors];

export type NfdPostOfferToOwnerResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdPostOfferToOwnerResponse =
  NfdPostOfferToOwnerResponses[keyof NfdPostOfferToOwnerResponses];

export type NfdPurchaseData = {
  body: PurchaseRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/purchase/{name}";
};

export type NfdPurchaseErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: unknown;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdPurchaseError = NfdPurchaseErrors[keyof NfdPurchaseErrors];

export type NfdPurchaseResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdPurchaseResponse =
  NfdPurchaseResponses[keyof NfdPurchaseResponses];

export type NfdRenewData = {
  body: RenewRequestBody;
  path?: never;
  query?: never;
  url: "/nfd/renew";
};

export type NfdRenewErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdRenewError = NfdRenewErrors[keyof NfdRenewErrors];

export type NfdRenewResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  201: string;
};

export type NfdRenewResponse = NfdRenewResponses[keyof NfdRenewResponses];

export type NfdRescindOfferData = {
  body: RescindOfferRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/rescindOffer/{name}";
};

export type NfdRescindOfferErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdRescindOfferError =
  NfdRescindOfferErrors[keyof NfdRescindOfferErrors];

export type NfdRescindOfferResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdRescindOfferResponse =
  NfdRescindOfferResponses[keyof NfdRescindOfferResponses];

export type NfdGetRevAddressSigData = {
  body?: never;
  path: {
    /**
     * An Algorand Account address
     */
    address: string;
  };
  query?: never;
  url: "/nfd/revAddressSig/{address}";
};

export type NfdGetRevAddressSigErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdGetRevAddressSigError =
  NfdGetRevAddressSigErrors[keyof NfdGetRevAddressSigErrors];

export type NfdGetRevAddressSigResponses = {
  /**
   * Algorand Address of Smart-Sig NAME account
   */
  200: string;
};

export type NfdGetRevAddressSigResponse =
  NfdGetRevAddressSigResponses[keyof NfdGetRevAddressSigResponses];

export type NfdSegmentLeadersData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: never;
  url: "/nfd/segment/leaders";
};

export type NfdSegmentLeadersErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSegmentLeadersError =
  NfdSegmentLeadersErrors[keyof NfdSegmentLeadersErrors];

export type NfdSegmentLeadersResponses = {
  /**
   * OK response.
   */
  200: NfdRecordCollection;
};

export type NfdSegmentLeadersResponse =
  NfdSegmentLeadersResponses[keyof NfdSegmentLeadersResponses];

export type NfdSegmentLockData = {
  body: SegmentLockRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/segment/lock/{name}";
};

export type NfdSegmentLockErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * segmentPriceTooLow: segment price doesn't meet minimum required price
   */
  403: unknown;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSegmentLockError =
  NfdSegmentLockErrors[keyof NfdSegmentLockErrors];

export type NfdSegmentLockResponses = {
  /**
   * Array of unsigned and signed grouped transactions to sign/submit
   */
  200: string;
};

export type NfdSegmentLockResponse =
  NfdSegmentLockResponses[keyof NfdSegmentLockResponses];

export type NfdSuggestData = {
  body?: never;
  path: {
    /**
     * A name (even partial) to search for [receiving suggestions as well]
     */
    name: string;
  };
  query: {
    /**
     * Limit the number of results returned - max 40
     */
    limit?: number;
    /**
     * View of data to return, brief (default), or full
     */
    view?: "brief" | "full";
    /**
     * An Algorand Account address
     */
    buyer: string;
  };
  url: "/nfd/suggest/{name}";
};

export type NfdSuggestErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * segmentNotSupported: parent segment isn't at contract version supporting segments
   */
  403: unknown;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSuggestError = NfdSuggestErrors[keyof NfdSuggestErrors];

export type NfdSuggestResponses = {
  /**
   * OK response.
   */
  200: NfdRecordCollection;
};

export type NfdSuggestResponse = NfdSuggestResponses[keyof NfdSuggestResponses];

export type NfdTotalsData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: never;
  url: "/nfd/totals";
};

export type NfdTotalsErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdTotalsError = NfdTotalsErrors[keyof NfdTotalsErrors];

export type NfdTotalsResponses = {
  /**
   * OK response.
   */
  200: TotalsOkResponseBody;
};

export type NfdTotalsResponse = NfdTotalsResponses[keyof NfdTotalsResponses];

export type NfdTwitterLeadersData = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: never;
  url: "/nfd/twitter/leaders";
};

export type NfdTwitterLeadersErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdTwitterLeadersError =
  NfdTwitterLeadersErrors[keyof NfdTwitterLeadersErrors];

export type NfdTwitterLeadersResponses = {
  /**
   * OK response.
   */
  200: Array<TwitterRecord>;
};

export type NfdTwitterLeadersResponse =
  NfdTwitterLeadersResponses[keyof NfdTwitterLeadersResponses];

export type NfdUpdatePartialData = {
  body: UpdatePartialRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/update/{name}";
};

export type NfdUpdatePartialErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * invalidFieldSet: You can only set user-defined properties, or clear verified properties
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * tooManyTransactions: The number of transactions allowed in a single transaction group (16) have been exceeded.  Update fewer fields in one transaction, or if selling, reduce the data within the NFD first.
   */
  413: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdUpdatePartialError =
  NfdUpdatePartialErrors[keyof NfdUpdatePartialErrors];

export type NfdUpdatePartialResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  202: string;
};

export type NfdUpdatePartialResponse =
  NfdUpdatePartialResponses[keyof NfdUpdatePartialResponses];

export type NfdUpdateAllData = {
  body: UpdatePartialRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/update/{name}";
};

export type NfdUpdateAllErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * invalidFieldSet: You can only set user-defined properties, or clear verified properties
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * tooManyTransactions: The number of transactions allowed in a single transaction group (16) have been exceeded.  Update fewer fields in one transaction, or if selling, reduce the data within the NFD first.
   */
  413: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdUpdateAllError = NfdUpdateAllErrors[keyof NfdUpdateAllErrors];

export type NfdUpdateAllResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  202: string;
};

export type NfdUpdateAllResponse =
  NfdUpdateAllResponses[keyof NfdUpdateAllResponses];

export type NfdUpdateImageData = {
  body?: never;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
    /**
     * An Algorand Account address
     */
    sender: string;
    /**
     * Which image to update, avatar or banner
     */
    which: "avatar" | "banner";
  };
  query?: {
    /**
     * Whether to return transactions to sign to update the specified image attribute within the NFD
     */
    wantTxn?: boolean;
  };
  url: "/nfd/updateImage/{name}/{sender}/{which}";
};

export type NfdUpdateImageErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * imageTooLarge: Images must be <10 Megabytes in size
   */
  413: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdUpdateImageError =
  NfdUpdateImageErrors[keyof NfdUpdateImageErrors];

export type NfdUpdateImageResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdUpdateImageResponse =
  NfdUpdateImageResponses[keyof NfdUpdateImageResponses];

export type NfdGetNfdsForAddressesV2Data = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query: {
    /**
     * one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address=xxx&address=yyy&address=zzz
     */
    address: Array<string>;
    /**
     * Limit the total number of NFDs returned - automatically changed to at least be 1 per address
     */
    limit?: number;
    /**
     * View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     */
    view?: "tiny" | "thumbnail" | "brief" | "full";
  };
  url: "/nfd/v2/address";
};

export type NfdGetNfdsForAddressesV2Errors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: unknown;
  /**
   * notFound: Not Found response.
   */
  404: unknown;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdGetNfdsForAddressesV2Error =
  NfdGetNfdsForAddressesV2Errors[keyof NfdGetNfdsForAddressesV2Errors];

export type NfdGetNfdsForAddressesV2Responses = {
  /**
   * OK response.
   */
  200: {
    [key: string]: NfdRecordinaddressCollection;
  };
};

export type NfdGetNfdsForAddressesV2Response =
  NfdGetNfdsForAddressesV2Responses[keyof NfdGetNfdsForAddressesV2Responses];

export type NfdDonationLeadersV2Data = {
  body?: never;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/v2/donations/leaders/{name}";
};

export type NfdDonationLeadersV2Errors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdDonationLeadersV2Error =
  NfdDonationLeadersV2Errors[keyof NfdDonationLeadersV2Errors];

export type NfdDonationLeadersV2Responses = {
  /**
   * OK response.
   */
  200: Array<Donation>;
};

export type NfdDonationLeadersV2Response =
  NfdDonationLeadersV2Responses[keyof NfdDonationLeadersV2Responses];

export type NfdDonationListV2Data = {
  body?: never;
  path?: never;
  query?: never;
  url: "/nfd/v2/donations/list";
};

export type NfdDonationListV2Errors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdDonationListV2Error =
  NfdDonationListV2Errors[keyof NfdDonationListV2Errors];

export type NfdDonationListV2Responses = {
  /**
   * OK response.
   */
  200: NfdRecordResponseFullCollection;
};

export type NfdDonationListV2Response =
  NfdDonationListV2Responses[keyof NfdDonationListV2Responses];

export type NfdSearchV2Data = {
  body?: never;
  headers?: {
    /**
     * etag
     */
    "if-none-match"?: string;
  };
  path?: never;
  query?: {
    /**
     * name or partial match of NFD name to filter on
     */
    name?: string;
    category?: Array<"curated" | "premium" | "common">;
    saleType?: Array<"auction" | "buyItNow">;
    state?: Array<"reserved" | "forSale" | "owned" | "expired">;
    /**
     * The parent NFD Application ID to find. Used for fetching segments of an NFD
     */
    parentAppID?: number;
    /**
     * Length of NFD
     */
    length?: Array<
      | "1_letters"
      | "2_letters"
      | "3_letters"
      | "4_letters"
      | "5_letters"
      | "6_letters"
      | "7_letters"
      | "8_letters"
      | "9_letters"
      | "10+_letters"
    >;
    /**
     * Traits of NFD
     */
    traits?: Array<"emoji" | "pristine" | "segment">;
    /**
     * An Algorand Account address
     */
    owner?: string;
    /**
     * An Algorand Account address
     */
    reservedFor?: string;
    /**
     * Should NFDs reserved for an account (transfers for example or unclaimed winning auctions) be excluded
     */
    excludeUserReserved?: boolean;
    /**
     * The start of an NFD name, fetching multiple NFDs that have that prefix
     */
    prefix?: string;
    /**
     * Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     */
    substring?: string;
    /**
     * Verified property name to search on - specify value with vvalue
     */
    vproperty?:
      | "blueskydid"
      | "discord"
      | "telegram"
      | "twitter"
      | "github"
      | "email"
      | "domain"
      | "nostrpubkey";
    /**
     * Value to find in the vproperty field specified with the vproperty parameter
     */
    vvalue?: string;
    /**
     * Whether to explicitly filter on segments being locked or unlocked.  Typically only valuable when filtering on unlocked
     */
    segmentLocked?: boolean;
    /**
     * Whether to explicitly filter on NFD roots or segments.  True to only see roots, False to only see segments.
     */
    segmentRoot?: boolean;
    /**
     * Minimum price of NFD
     */
    minPrice?: number;
    /**
     * Maximum price of NFD
     */
    maxPrice?: number;
    /**
     * Minimum price of NFD Segment in USD (cents)
     */
    minPriceUsd?: number;
    /**
     * Maximum price of NFD Segment in USD (cents)
     */
    maxPriceUsd?: number;
    /**
     * Fetch NFDs that changed after the specified timestamp
     */
    changedAfter?: string;
    /**
     * Return only NFDs with an expiration time at or before the specified timestamp
     */
    expiresBefore?: string;
    /**
     * Limit the number of results returned - max 200
     */
    limit?: number;
    /**
     * Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     */
    offset?: number;
    /**
     * What to sort on
     */
    sort?:
      | "createdDesc"
      | "timeChangedDesc"
      | "soldDesc"
      | "priceAsc"
      | "priceDesc"
      | "highestSaleDesc"
      | "saleTypeAsc"
      | "nameAsc"
      | "expiresAsc"
      | "expiresDesc";
    /**
     * View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     */
    view?: "tiny" | "thumbnail" | "brief" | "full";
  };
  url: "/nfd/v2/search";
};

export type NfdSearchV2Errors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSearchV2Error = NfdSearchV2Errors[keyof NfdSearchV2Errors];

export type NfdSearchV2Responses = {
  /**
   * OK response.
   */
  200: NfdV2SearchRecords;
};

export type NfdSearchV2Response =
  NfdSearchV2Responses[keyof NfdSearchV2Responses];

export type NfdContractUpgradeV3Data = {
  body: RescindOfferRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/v3/contract/upgrade/{name}";
};

export type NfdContractUpgradeV3Errors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeNotNeeded: The NFD contract doesn't need upgraded
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdContractUpgradeV3Error =
  NfdContractUpgradeV3Errors[keyof NfdContractUpgradeV3Errors];

export type NfdContractUpgradeV3Responses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdContractUpgradeV3Response =
  NfdContractUpgradeV3Responses[keyof NfdContractUpgradeV3Responses];

export type NfdVaultOptInLockData = {
  body: ContractLockRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/vault/lock/{name}";
};

export type NfdVaultOptInLockErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdVaultOptInLockError =
  NfdVaultOptInLockErrors[keyof NfdVaultOptInLockErrors];

export type NfdVaultOptInLockResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdVaultOptInLockResponse =
  NfdVaultOptInLockResponses[keyof NfdVaultOptInLockResponses];

export type NfdSendFromVaultData = {
  body: SendFromVaultRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/vault/sendFrom/{name}";
};

export type NfdSendFromVaultErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSendFromVaultError =
  NfdSendFromVaultErrors[keyof NfdSendFromVaultErrors];

export type NfdSendFromVaultResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdSendFromVaultResponse =
  NfdSendFromVaultResponses[keyof NfdSendFromVaultResponses];

export type NfdSendToVaultData = {
  body: SendToVaultRequestBody;
  path: {
    /**
     * Name of a NFD, alphanumeric only or emojis/alphanumeric
     */
    name: string;
  };
  query?: never;
  url: "/nfd/vault/sendTo/{name}";
};

export type NfdSendToVaultErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * upgradeRequired: The NFD contract needs upgraded before this operation will be allowed
   */
  403: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * tooManyTransactions: The number of transactions allowed in a single transaction group (16) have been exceeded.
   */
  413: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdSendToVaultError =
  NfdSendToVaultErrors[keyof NfdSendToVaultErrors];

export type NfdSendToVaultResponses = {
  /**
   * Returns (as escaped string) array of paired values representing a transaction group to submit to an Algorand node. u or s for unsigned or signed, followed by the base64-encoded message-pack of an unsigned transaction (to be signed by sender/buyer) or a signed transaction to be submitted as-is.
   */
  200: string;
};

export type NfdSendToVaultResponse =
  NfdSendToVaultResponses[keyof NfdSendToVaultResponses];

export type NfdVerifyConfirmData = {
  body: VerifyConfirmRequestBody;
  path: {
    /**
     * ID of challenge, must be used in subsequent confirmation call
     */
    id: string;
  };
  query?: never;
  url: "/nfd/verify/confirm/{id}";
};

export type NfdVerifyConfirmErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * noNFDNSubscription: No active subscription to NFDN
   */
  403: unknown;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdVerifyConfirmError =
  NfdVerifyConfirmErrors[keyof NfdVerifyConfirmErrors];

export type NfdVerifyConfirmResponses = {
  /**
   * OK response.
   */
  200: VerifyConfirmResponseBody;
};

export type NfdVerifyConfirmResponse =
  NfdVerifyConfirmResponses[keyof NfdVerifyConfirmResponses];

export type NfdVerifyRequestData = {
  body: VerifyRequestRequestBody;
  path?: never;
  query?: never;
  url: "/nfd/verify/request";
};

export type NfdVerifyRequestErrors = {
  /**
   * invalidAddress: invalidAddress is returned for an Algorand address that doesn't appear to be valid
   */
  400: _Error;
  /**
   * notFound: Not Found response.
   */
  404: _Error;
  /**
   * rateLimited: Too Many Requests response.
   */
  429: RateLimited;
};

export type NfdVerifyRequestError =
  NfdVerifyRequestErrors[keyof NfdVerifyRequestErrors];

export type NfdVerifyRequestResponses = {
  /**
   * OK response.
   */
  200: VerifyRequestResponseBody;
};

export type NfdVerifyRequestResponse =
  NfdVerifyRequestResponses[keyof NfdVerifyRequestResponses];
